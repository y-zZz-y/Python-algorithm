# 2. Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
#
# Первый — с помощью алгоритма «Решето Эратосфена».
#
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
#
# Второй — без использования «Решета Эратосфена».
#
# Примечание. Вспомните классический способ проверки числа на простоту.
#
# Пример работы программ:
#
# >>> sieve(2)
# 3
# >>> prime(4)
# 7
# >>> sieve(5)
# 11
# >>> prime(1)
# 2

def sieve(n):
    """Решето Эратосфена"""
    myrange = 3 if n < 2 else n**2

    s = [i for i in range(myrange)]
    s[1] = 0

    for i in range(2, myrange):
        if s[i] != 0:
            j = i*2

            while j < myrange:
                s[j] = 0
                j += i

    result = [i for i in s if i != 0]
    return result[n-1]


def prime(n):
    """Алгоритм остановится на числе, которое будет делителем числа n"""
    d = 2
    while n % d != 0:
        d += 1
    return d == n

def prime2(n):
    """Чиcло n является простым, если алгоритм закончился по причине того, что проверяемый делитель стал больше, чем корень из n."""
    d = 2
    while d * d <= n and n % d != 0:
        d += 1
    return d * d > n

def prime3(n):
    """Перебор нечетных делителей"""
    if n % 2 == 0:
        return n == 2
    d = 3
    while d * d <= n and n % d != 0:
        d += 2
    return d * d > n

print(sieve(2000))
print(sieve(4))
print(sieve(5))
print(sieve(1))